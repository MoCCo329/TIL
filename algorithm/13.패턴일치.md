## 13. 패턴일치

### 1. 고지식한 패턴 검색 알고리즘

문자열 t와 p를 인덱스 i와 j로 검사할 때, j<M and i<N인 한 t[i]와 p[j]가 일치하면 i, j를 동시에 증가, 실패하면 i원점에서 한칸 증가(i-j+1)하고 j는 0으로 되돌린다.

O(MN)의 시간복잡도를 갖는다.

<br>

### 2. 카프-라빈 알고리즘

패턴을 해쉬함수를 거치고 문자열을 해쉬값으로 매칭하며 확인하는 방식이다.

매번 해쉬값을 구하면 고지식한 패턴 검색과 다를바가 없으므로 다음 해시값을 구할 때 새로 들어오는 수만 추가하고 맨 뒤 값은 버린 뒤 해쉬값을 구한다.

패턴이 길어지면 mod 연산을 취하기 때문에 해쉬 충돌이 일어날 수 있다.

O(MN)의 시간복잡도를 가지지만, 평균적으론 M + N 이다.

<br>

### 3. KMP 알고리즘

불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행한다.

O(M+N)의 시간복잡도를 갖는다.

```python
T = input()
P = input()
tL = len(T)
pL = len(P)
lps = [0] * pL

j = 0
for i in range(1, pL):
    while j > 0 and P[i] != P[j]:
        j = lps[j - 1]

    if P[i] == P[j]:
        j += 1
        lps[i] = j

ans_list = []
j = 0
for i in range(tL):
    while j > 0 and T[i] != P[j]:
        j = lps[j - 1]

    if T[i] == P[j]:
        if j == pL - 1:
            ans_list.append(i - pL + 2)
            j = lps[j]
        else:
            j += 1

print(*ans_list)
```

원래라면 택스트 인덱스인 한 i에 대해서 패턴 길이만큼 검사를 해야하지만, 중단된 위치부근이 패턴의 접미사와 일치하는 부분이 있는 경우 해당 접미사에 대한 검사를 건너 뛸 수 있다.

무엇이 패턴이고 무엇이 택스트인지 언급이 없으면 찾는 과정이 추가로 필요하다.

<br>

### 4. 보이어-무어 알고리즘

오른쪽에서 왼쪽으로 비교하는 방식으로 대부분의 소프트웨어에서 채택하고 있다. 패턴의 오른쪽 끝에 있는 문자가 불일치 하고, 이 문자가 패턴 내에 존재하지 않는 경우, 패턴의 이동길이만큼 이동하는 방식이다.

패턴의 오른쪽 끝에 있는 문자가 불일치 한 경우 패턴의 뒤에서부터 비교했던 택스트의 문자와 일치하는 문자가 있는지 찾고, 일치하는 문자가 있으면 그 부분까지 점프한다.

skip 배열을 활용하며 skip[ch]는 ch 문자에서 패턴 불일치가 발생했을 때 이동할 문자열 포인터 수를 나타낸다.

패턴 포인터는 패턴의 맨 뒤를 가리키다가 일치하는 글자를 찾으면 패턴의 다른 글자도 확인한다.

최선의 경우 O(N/M)(빅 오메가로 최선의 경우를 표시 가능) 최악의 경우 O(MN)(빅오는 최악의 경우, 세타는 평균적인 복잡도)의 시간 복잡도를 갖는다.

