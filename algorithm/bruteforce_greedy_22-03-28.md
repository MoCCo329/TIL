## 완전탐색과 그리디

### 1. 반복(Iteration)과 재귀(Recursion)

- 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택한다.
- 재귀는 알고리즘 설계가 간단하고 짧지만, 더 많은 메모리와 연산을 필요로 한다. 때문에 입력값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.



### 2. 완전탐색(Brute Force)

- 순열

```python
def f(i, k, n):
    if i == k:
        print(p)
    else:
         for j in range(m):
                if used[j] == 0:
                    used[j] = 1
                    p[i] = a[j]
                   	f(i+1, k, m)
                    used[j] = 0
	return

a = [1, 2, 3, 4, 5]
p = [0] * 3
used = [0] * 5
f(0, 3, 5)  # 5개중 3개를 고르는 중복순열을 사전순으로 나열
```



- 부분집합

```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)

for i in range(1<<n):
    for j in range(n):
        if i & (1<<j):
            print('%d'%arr[j], end='')
    print()
```



- 조합

```python
def nCr(n, r, s, k):  # s는 선택할 수 있는 구간의 시작, k는 (r - 고른 개수)
    if k == 0:
        print(*comb)
    else:
        for i in range(s, n - k + 1):
            comb[r - k] = A[i]  # k을 줄여가며 인덱스로 사용
            nCr(n, r, i + 1, k - 1)

n = 5
r = 3
comb = [0] * 3
A = [i for i in range(1, n+1)]
nCr(n, r, 0, 0)
```



### 3. 탐욕(Greedy)

- 탐욕 기법을 적용한 활동 선택(Activity-selection) 문제

```python
Sort A by finish time

S = A[0]
j = 0
for i in range(1, N):
    if si >= fj:  # i의 시작 시간이 j가 끝나는 시간 이후면
        S = S | A[i]  # S에 A[i] 작업을 칠한다
        j = i
```



- 탐욕 기법과 동적 계획법의 비교

| 탐욕 기법                                                    | 동적 계획법                                             |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| 매 단계에서, 가장 좋게 보이는 것을 빠르게 선택한다.<br />-> 지역 최적 선택(local optimal choice) | 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 한다. |
| 하위 문제를 풀기 전에 (탐욕적) 선택이 먼저 이루어진다.       | 하위 문제가 우선 해결된다.                              |
| Top-down 방식                                                | Bottom-up 방식                                          |
| 일반적으로, 빠르고 간결하다.                                 | 좀 더 느리고, 복잡하다.                                 |



- 대표적인 탐욕 기법의 알고리즘들

| 알고리즘            | 목적                                                         | 설명                                                         |        |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------ |
| Prim                | N 개의 노드에 대한 최소 신장 트리(MST)를 찾는다.             | 서브트리를 확장하면서 MST를 찾는다.                          | 그래프 |
| Kruskal             | N 개의 노드에 대한 최소 신장 트리(MST)를 찾는다.             | 사이클이 없는 서브 그래프를 확장하면서 MST를 찾는다.         | 그래프 |
| Dijkstra            | 주어진 정점에서 다른 정점들에 대한 최단 경로를 찾는다.       | 주어진 정점에서 가장 가까운 정점을 찾고, 그 다음을 정점을 반복해서 찾는다. | 그래프 |
| Huffman tree & code | 문서의 압축을 위해 문자들의 빈도수에 따라 코드값을 부여한다. | 출현 빈도가 낮은 문자부터 선택해서 이진 트리를 완성하고 코드값을 부여한다. | 문자열 |

