## 13. 패턴일치

### 1. 고지식한 패턴 검색 알고리즘

문자열 t와 p를 인덱스 i와 j로 검사할 때, j<M and i<N인 한 t[i]와 p[j]가 일치하면 i, j를 동시에 증가, 실패하면 i원점에서 한칸 증가(i-j+1)하고 j는 0으로 되돌린다.

O(MN)의 시간복잡도를 갖는다.

<br>

### 2. 카프-라빈 알고리즘

<br>

### 3. KMP 알고리즘

불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행한다.

O(M+N)의 시간복잡도를 갖는다.

```python
def kmp(t, p):
    N = len(t) # 택스트
    M = len(p) # 패턴
    #패턴속 일치하는 접두사 접미사 수 찾기
    lps = [0] * (M+1)
    
    j = 0 # 일치한 개수 == 비교할 패턴 위치
    lps[0] = -1 # lps[0] = -1, lps[1] = 0 으로 고정이다.
    for i in range(1, M):
        lps[i] = j # p[i] 이전에 일치한 개수
        if p[i] == p[j]:
            j += 1
        else:
            j = 0
    lps[M] = j
    
    #search
    i = 0 # 비교할 택스트 위치
    j = 0 # 비교할 패턴 위치
    while i < N and j <= M:
        if j == -1 or t[i] == p[j]: # 일치하는 경우 i와 j 둘 다 증가. 
            i += 1
            j += 1
        else: # 접미사 건너뛰기위해 j = lps[j]. 패턴의 j 위치에서 앞부분과 얼마나 겹치는지를 불러온다.
            j = lps[j]
        if j == M:
            print(i-M, end=' ')
            j = lps[j]
```

원래라면 택스트 인덱스인 한 i에 대해서 패턴 길이만큼 검사를 해야하지만, 중단된 위치부근이 패턴의 접미사와 일치하는 부분이 있는 경우 해당 접미사에 대한 검사를 건너 뛸 수 있다.

무엇이 패턴이고 무엇이 택스트인지 언급이 없으면 찾는 과정이 추가로 필요하다.

<br>

### 4. 보이어-무어 알고리즘

오른쪽에서 왼쪽으로 비교하는 방식으로 대부분의 소프트웨어에서 채택하고 있다. 패턴의 오른쪽 끝에 있는 문자가 불일치 하고, 이 문자가 패턴 내에 존재하지 않는 경우, 패턴의 이동길이만큼 이동하는 방식이다.

패턴의 오른쪽 끝에 있는 문자가 불일치 한 경우 패턴의 뒤에서부터 비교했던 택스트의 문자와 일치하는 문자가 있는지 찾고, 일치하는 문자가 있으면 그 부분까지 점프한다.

최선의 경우 O(n)(빅 오메가로 최선의 경우를 표시 가능) 최악의 경우 O(mn)(빅오는 최악의 경우, 세타는 평균적인 복잡도)의 시간 복잡도를 갖는다.