## Tree

### 1. Tree 란

- 원소들 간에 계층관계를 가지는 계층형 구조이며, 상위원소에서 하위원소로 내려가며 확장되는 나무 모양의 구조이다. 비선형의 자료구조로, 원소들 간에 1:n 관계를 가진다.

- 한개 이상의 노드로 이루어진 유한 집합이며 정점(node, vertex)과 정점사이 간선으로 이루어 진다.

- 노드 중 최상위 노드를 루트 노드(root node)라 하며, 루트의 부 트리(subtree)는 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리이다.

- 형제 노드는 같은 부모 노드의 자식 노드들을

  조상 노드는 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들을

  자손 노드는 서브트리에 있는 하위 레벨의 노드들을

  단말노드 또는 잎(leaf) 노드는 말단에 붙은 노드를 말한다.

- 노드의 차수는 노드에 연결된 자식 노드의 수이다. 트리의 차수는 가장 큰 차수를 말한다. 뿌리 노드의 높이는 0이며 트리의 최대 높이는 트리 차수와 같다(뿌리 노드가 높이 0부터 시작하는경우).



### 2. 이진트리(Binary Tree)

- 각 노드가 자식 노드를 최대한 2개 까지 가질 수 있는 트리. 높이가 h인 이진 트리가 가지는 최대 노드 수는 2^(h+1)-1 이 된다.
- 포화 이진 트리(Full Binary Tree)는 모든 레벨의 노드가 포화상태로 차 있는 이진 트리를 말한다.

- 완전 이진 트리(Complete Binary Tree)는 노드 번호 1번부터 n번까지 빈 자리 없이 채워진 이진 트리이다.
- 편향 이진 트리(Shewed Binary Tree)는 한 노드에서 최소한의 자식 수를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리이다.



### 3. 이진트리 순회(Traversal)

- 순회는 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말한다. 트리는 비 선형 구조로 선후 연결관계를 알지 못해 일반적인 접근이 불가능하다. 따라서 다음과 같은 세가지 방법을 사용한다.

- 전위 순회(preorder traversal) - 부모노드를 우선처리, 이후 자식노드를 좌, 우 순서로 방문한다.

```python
def pre_order(v):
    if v: # 존재하는 정점이면
        print(v) # visit()
        pre_order(ch1[v]) # 왼쪽 자식 노드로 이동
        pre_order(ch1[v]) # 오른쪽 자식 노드로 이동
```

- 중위순회(inorder traversal) - 왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순으로 방문한다.

```python
def in_order(v):
    if v:
        in_order(ch1[v])
        print(V)
        in_order(ch2[v])
```

- 후위순회(postorder traversal) - 왼쪽, 오른쪽 자식노드를 방문한 후 부모노드를 방문한다.

```python
def post_order(v):
    if v:
        post_order(ch1[v])
        post_order(ch2[v])
        print(v)
```



### 4. 이진트리 표현

- 배열

  노드번호가 루트의 번호를 1로, 이후 자식들을 왼쪽부터 오른쪽으로 번호를 매긴다면 트리의 n레벨에는 2^n 부터 2^n-1까지 노드번호가 새겨지게 된다. 노드번호 i의 부모 노드번호는 i//2이며, 노드 번호가 i인 노드의 왼쪽과 오른쪽 자식 번호는 각각 2\*i, 2\*i+1이다.

  이와 같은 노드번호의 규칙이 있는 경우, 노드번호를 인덱스로 하여 정점의 정보를 저장할 수 있다. 트리의 높이를 h라 하고 0부터 시작하면 전체 노드의 수는 2^0 + 2^1 + 2^2 + ... + 2^h = 2^(h+1) - 1의 배열 크기가 필요하다.

- 저장

  노드번호의 규칙이 없는 경우, 부모와 자식관의 관계를 저장하는 식으로 이진트리를 표현하게 된다.

```python
# 입력 받기
V = int(intput()) # 정점 수
E = V - 1 # 간선 수
arr = list(map(int, input().spit()))

# 부모를 인덱스로 자식번호 저장
ch1 = [0]*(V+1)
ch2 = [0]*(V+1)
for i in range(E):
    p, c = arr[i*2], arr[i*2+1]
    if ch1[p] == 0:
        ch1[p] = c
    else:
        ch2[p] = c
        
# 자식을 인덱스로 부모번호 저장
par = [0]*(V+1)
for i in range(E):
    p, c = arr[i*2], arr[i*2+1]
    par[c] = p

# root 찾기
root = 1
for i in range(1, V+1):
    if par[i] == 0:
        root = i
        break
        
# 조상 찾기
anc = []
v = 5
while par[v] != 0:
    anc.append(par[v])
    v = par(v)
```

