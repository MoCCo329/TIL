## Tree

### 1. Tree 란

- 원소들 간에 계층관계를 가지는 계층형 구조이며, 상위원소에서 하위원소로 내려가며 확장되는 나무 모양의 구조이다. 비선형의 자료구조로, 원소들 간에 1:n 관계를 가진다.

- 한개 이상의 노드로 이루어진 유한 집합이며 정점(node, vertex)과 정점사이 간선으로 이루어 진다.

- 노드 중 최상위 노드를 루트 노드(root node)라 하며, 루트의 부 트리(subtree)는 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리이다.

- 형제 노드는 같은 부모 노드의 자식 노드들을

  조상 노드는 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들을

  자손 노드는 서브트리에 있는 하위 레벨의 노드들을

  단말노드 또는 잎(leaf) 노드는 말단에 붙은 노드를 말한다.

- 노드의 차수는 노드에 연결된 자식 노드의 수이다. 트리의 차수는 가장 큰 차수를 말한다. 뿌리 노드의 높이는 0이며 트리의 최대 높이는 트리 차수와 같다(뿌리 노드가 높이 0부터 시작하는경우).



### 2. 이진트리(Binary Tree)

- 각 노드가 자식 노드를 최대한 2개 까지 가질 수 있는 트리. 높이가 h인 이진 트리가 가지는 최대 노드 수는 2^(h+1)-1 이 된다.
- 포화 이진 트리(Full Binary Tree)는 모든 레벨의 노드가 포화상태로 차 있는 이진 트리를 말한다.

- 완전 이진 트리(Complete Binary Tree)는 노드 번호 1번부터 n번까지 빈 자리 없이 채워진 이진 트리이다.
- 편향 이진 트리(Shewed Binary Tree)는 한 노드에서 최소한의 자식 수를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리이다.



### 3. 이진트리 순회(Traversal)

- 순회는 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말한다. 트리는 비 선형 구조로 선후 연결관계를 알지 못해 일반적인 접근이 불가능하다. 따라서 다음과 같은 세가지 방법을 사용한다.

- 전위 순회(preorder traversal) - 부모노드를 우선처리, 이후 자식노드를 좌, 우 순서로 방문한다.

```python
def pre_order(v):
    if v: # 존재하는 정점이면
        print(v) # visit()
        pre_order(ch1[v]) # 왼쪽 자식 노드로 이동
        pre_order(ch1[v]) # 오른쪽 자식 노드로 이동
```

- 중위순회(inorder traversal) - 왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순으로 방문한다.

```python
def in_order(v):
    if v:
        in_order(ch1[v])
        print(V)
        in_order(ch2[v])
```

- 후위순회(postorder traversal) - 왼쪽, 오른쪽 자식노드를 방문한 후 부모노드를 방문한다.

```python
def post_order(v):
    if v:
        post_order(ch1[v])
        post_order(ch2[v])
        print(v)
```



### 4. 이진트리 표현

- 배열

  완전 이진트리의 경우 노드번호가 루트의 번호를 1로, 이후 자식들을 왼쪽부터 오른쪽으로 번호를 매긴다면 트리의 n레벨에는 2^n 부터 2^n-1까지 노드번호가 새겨지게 된다. 노드번호 i의 부모 노드번호는 i//2이며, 노드 번호가 i인 노드의 왼쪽과 오른쪽 자식 번호는 각각 2\*i, 2\*i+1이다.

  ```python
  def pre_order(v):
      global last
      if v <= last:
          print(v)
          pre_order(v * 2)
          pre_order(v * 2 + 1)
  ```

  이와 같은 노드번호의 규칙이 있는 경우, 노드번호를 인덱스로 하여 정점의 정보를 저장할 수 있다. 트리의 높이를 h라 하고 0부터 시작하면 전체 노드의 수는 2^0 + 2^1 + 2^2 + ... + 2^h = 2^(h+1) - 1의 배열 크기가 필요하다. 편향 이진 트리의 경우에 사용하지 않는 배열 원소에 대한 메모리 낭비가 발생하며, 트리의 중간에 새로운 노드를 삽입히거나 기존의 노드를 삭제할 경우 배열의 변경이 어려워 비효율적이다.

- 관계 저장

  노드번호의 규칙이 없는 경우, 부모와 자식관의 관계를 저장하는 식으로 이진트리를 표현하게 된다.

```python
# 입력 받기
V = int(intput()) # 정점 수
E = V - 1 # 간선 수
arr = list(map(int, input().spit()))

# 부모를 인덱스로 자식번호 저장
ch1 = [0]*(V+1)
ch2 = [0]*(V+1)
for i in range(E):
    p, c = arr[i*2], arr[i*2+1]
    if ch1[p] == 0:
        ch1[p] = c
    else:
        ch2[p] = c
        
# 자식을 인덱스로 부모번호 저장
par = [0]*(V+1)
for i in range(E):
    p, c = arr[i*2], arr[i*2+1]
    par[c] = p

# root 찾기
root = 1 # 임시값
for i in range(1, V+1):
    if par[i] == 0:
        root = i
        break
        
# 조상 찾기
anc = []
v = 5
while par[v] != 0:
    anc.append(par[v])
    v = par[v]
print(*anc)
```

- 연결리스트(Linked list)

  배열을 이용한 표현의 단점을 보완하기 위해 연결리스트를 이용하여 트리를 표현한 것이다. 메모리에 노드번호에 관계없이 흩어져 저장되며 가장 왼쪽에 왼쪽 자식 노드 주소 정보가, 가운데는 데이터가, 오른쪽엔 오른쪽 자식 노드 주소 정보가 한 세트로 들어간다.



### 5. 이진 탐색 트리

- 탐색 작업을 효율적으로 하기 위한 자료구조로 왼쪽 서브트리 키 < 루트노드 키 < 오른쪽 서브트리 키 의 규칙을 가지고 키를 갖게 된다. 따라서 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있다.
- 탐색의 경우 탐색할 키 값을 루트노드와 비교 후 작으면 루트노드 왼쪽 서브트리로, 크면 오른쪽 서브트리로 이동하며 같으면 탐색을 마치게 된다.
- 삽입의 경우 먼저 탐색을 통해 삽입하려는 원소가 이미 트리에 있는지 확인한다. 이 때 탐색을 실패한 위치에 원소를 삽입한다.
- 탐색(searching), 삽입(insertion), 삭제(deletion)에 걸리는 시간은 트리의 높이만큼 걸린다 O(h) , 따라서 이진트리가 좌, 우로 균형적으로 생성되어 있는 경우 평균 O(log n)의 시간 복잡도를, 편향이진트리의 최악의 경우 O(n)의 시간복잡도를 갖으며 이는 순차탐색과 시간복잡도가 같다.



### 6. 힙(Heap)

- 완전 이진 트리에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해 만든 자료구조이다.
- 최대 힙(max heap)은 키값이 가장 큰 노드를 찾기 위한 완전 이진 트리로 부모노드의 키 값이 자식노드의 키 값보다 크다. 따라서 루트 노드는 키값이 가장 큰 노드이다.
- 최소 힙(min heap)은 키값이 가장 작은 노드를 찾기 위한 완전 이진 트리로 부모노드의 키 값이 자식노드의 키 값보다 작다. 따라서 루트 노드는 키값이 가장 작은 노드이다.



- 삽입

  최대힙의 경우 최대 노드에 자식노드를 추가한다. 부모 노드보다 자식 노드의 키값이 크다면 둘의 위치를 바꾼다. 조건을 만족하거나 뿌리노드에 도달할 때까지 계속해서 부모노드와 자리를 바꾼다.

```python
def enq(n):
    global last
    last += 1
    tree[last] = n # 완전 이진트리 유지
    c = last # 새로 추가된 정점을 자식으로
    p = c//2 # 완전이진트리에서 부모의 정점 번호
    while p >= 1 and tree[p] < tree[c]: # 부모노드가 있고, 자식의 키값이 더 크면 교환
        tree[p], tree[c] = tree[c], tree[p]
		c = p
        p = c // 2
    
tree = [0]*(101) # 완전이진트리의 정점번호 1~100
last = 0 # 마지막 정점 번호
```

- 삭제

  루트 노드만 삭제 가능하다. 루트 노드를 삭제 후, 맨 마지막 노드를 삭제하여 루트 노드로 옮긴다. 이후 자식노드의 키 값이 더 작아지거나 자식노드가 없을 때까지 자리를 바꾼다.

```python
def deq():
    global last
    tmp = tree[1] # 루트의 키값
    tree[1] = tree[last] # 마지막 정점의 키를 루트에 저장
    last -= 1 # 마지막 정점 삭제
    
    p = 1
    c = p*2 # 왼쪽 자식 노드 번호
    while c <= last:
        if c + 1 <= last and tree[c] < tree[c+1]: # 오른쪽 자식 노드도 있고 더 크면
            c += 1 # 오른쪽 자식 선택
        if tree[p] < tree[c]: # 자식의 키 값이 더 크면 교환
            tree[p], tree[c] = tree[c], tree[p]
            p = c
            c = p * 2
        else:
            break
    return tmp
```

- 힙 구조에서 deq()를 반복하면 값이 내림차순으로 나오게 된다. 이를 힙소트(Heap sort)라 한다.
