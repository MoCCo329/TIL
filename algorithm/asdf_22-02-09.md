- 무엇이 좋은 알고리즘인가?

정확성

작업량

메모리 사용량

단순성

최적성



- 시간복잡도

빅-오 표기법 (Big-Oh Notation)

n에 대한 항만을 표시하며 계수는 생략하여 표시한다

1 logn n nlogn n2 2n n!f



- 배열

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조. 배열로 효율적으로 문제풀이가능. Arr = [0]*10 처럼 선언과 초기화를 동시에 가능하다.



- 정렬의 종류

버블 정렬 : 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식. 가장 큰 원소가 마지막 자리로 정렬되며 이동하는 모습이 거품을 연상시켜 버블정렬이라 한다.

```python
def bubble_sort(a, N):
    for i in range(N-1, 0, -1):
        for j in range(i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
    return
                
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = list(map(int, input().split()))
    bubble_sort(arr, N)
    print(f'#{tc}', end=' ')
    print(*arr)
```

print(*arr) 하면 순회컨테이너가 풀려나온다.

중간까지의 출력을 통해 디버깅하는 습관



카운팅 정렬 : 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트배열 counts에 저장한다.

저장소를 지정해주면 계산이 빨라지는 경우가 있는데 그런 케이스이다..(?)

counts[A[i]] += 1

counts 리스트는 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 누적합으로 원소를 조정한다.

counts[i] += counts[i-1]

다시 counts리스트를 정렬된 



선택 정렬

퀵 정렬

삽입 정렬

병합 정렬





완전검색으로 시작하라 (수행속도가 느리다, 해답을 못찾을 확률이 낮다)

순열 조합

탐욕(Greedy) 알고리즘 : 1) 해 선택 - 현재 상태에서 부분 문제의 최적 해를 구한 뒤 이를 부분해집합에 추가한다 2) 실행 가능성 검사 - 새로운 부분해 집합이 실행 가능한지를 확인한다. 3) 해 검사 - 

`