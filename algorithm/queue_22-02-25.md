## Queue

### 1. 큐(Queue)의 특성

- 선입선출 구조로 머리는 Front, 꼬리는 Rear
- enQueue는 삽입
- deQueue은 삭제
- createQueue() 공백상태의 큐를 생성
- isEmpty() 큐가 빈 상태인지 확인 Front와 Rear가 같은지
- isFull() 
- Qpeek 큐의 앞쪽 원소를 삭제없이 반환



상태표현

초기상태 front = rear = -1

공백상태 front == rear

포화상태 rear == n-1(n : 배열의 크기, n-1 : 배열의 마지막 인덱스)



잘못된 포화상태 인식. 선형큐를 이용하여 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분이 비어있지만, rear = n-1로 포화상태로 인식하여 더이상의 삽입을 수행하지 않게되기도 한다.

해결방법1. 매 연산이 이루어질 때마다 원소들을 앞부분으로 이동시키는 방식은 많은 시간이 소요되어 큐의 효율성이 급격히 떨어진다.

해결방법2. 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결된 원형형태의 큐를 이룬다고 가정하고 사용한다. 초기 공백상태를 front = rear = 0으로 두고 mod를 이용해 순환시킨다.

공백상태와 포화상태 구분을 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 한다. 공백상태이면 front == rear이며 포화상태이면 rear의 다음위치가 현재 front가 된다.

원형큐가 가득 찼을 때 front를 비울 것인지, rear를 비울것인지.



우선순위 큐(Priority Queue)

우선순위를 가진 항목들을 저장하는 큐로 FIFO 순서가 아니라 우선순위대로 먼저 나가게 된다.(시뮬레이션 시스템, 네트워크 트래픽 제어, 운영체제의 테스크 스케줄링)

가장 앞에 최고 우선순위의 원소가 위치하게 된다.(보통은 트리구조를 통해 구현한다) 배열을 사용하면 삽입이나 연산이 일어날 때 원소의 재배치가 발생한다.



큐의 활용 : 버퍼(Buffer)

데이터를 한 곳에서 다른곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역이다.

버퍼링은 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미한다.

버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용되며 순서대로 입출력 되어야 하므로 FIFO구조인 큐를 활용한다.



### BFS(Breath First Search)





```python
def BFS(G, v): # 그래프G, 탐색 시작점 v
    visited = [0]*(n+1) # n : 정점의 개수
    queue = []
    queue.append(v) # 시작점 v를 큐에 삽입
    whiel queue: # 큐가 비어있지 않은 경우
        t = queue.pop(0)
        if not visited[t]:
            visited[t] = True # 방문한 것으로 표시
            visit(t) # 정점 t에서 할 일
        for i in G[t]: # t와 연결된 모든 정점에 대해
            if not visited[i]: # 방문되지 않은 곳이라면
                queue.append(i) # 큐에 넣기
                
                
                
def BFS(G, v, n):
    visited = [0]*(n+1)
    queue = []
    queue.append(v)
    visited[v] = 1
    while queue:
        t = queue.pop(0)
        visit(t)
        for i in G[t]:
            if not visited[i]:
                queue.append(i)
                visited[i] = visited[t]+1
```

큐에 추가할 때 방문지에 표시

