## List1 개념

### 1. 무엇이 좋은 알고리즘인가?

- 정확성

- 작업량

- 메모리 사용량

- 단순성

- 최적성



### 2. 시간복잡도 <-> 공간복잡도(메모리)

- 보통 빅-오 표기법(Big-Oh Notation)을 이용한다.

- n에 대한 항만을 표시하며 계수는 생략하여 표시한다

- 1 < logn < n < nlogn < n2 < 2n < n!



### 3. 배열

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조. 배열로 효율적으로 문제풀이가능. Arr = [0]*10 처럼 선언과 초기화를 동시에 가능하다.



### 4. 정렬의 종류

- 버블 정렬 : 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식. 가장 큰 원소가 마지막 자리로 정렬되며 이동하는 모습이 거품을 연상시켜 버블정렬이라 한다. O(n2)의 시간 복잡도를 가진다.

```python
def bubble_sort(a, N):
    for i in range(N-1, 0, -1):
        for j in range(i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
    return
                
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = list(map(int, input().split()))
    bubble_sort(arr, N)
    print(f'#{tc}', *arr)
    #print(*arr) 하면 순회컨테이너가 풀려나온다.
```

- 카운팅 정렬 :  집합의 각 항목이 몇개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 효율적인 알고리즘이다. O(n+k)의 시간 복잡도를 가지며 공간 복잡도는 좋지 못하다.

1단계 - 각 항목들의 발생 횟수를 세고, 해당 항목을 인덱스로 하는 카운트배열 counts에  발생 횟수를 저장한		다. (음수의 경우 일정수를 더해주며, 소수는 곱해준다. 하지만 소수의 경우 잘 쓰지 않는다.)

counts[A[i]] += 1

2단계 - counts 리스트는 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 누적합으로 원소를 조정한다.

counts[i] += counts[i-1] (1부터 인덱싱)

3단계 - DATA리스트의 값을 하나씩 빼면서 해당 counts 인덱스의 수를 인덱스로하여 TEMP리스트에 넣는다.

counts[DATA[i]] -= 1

TEMP[counts[DATA[i]]] = DATA[i] (인덱싱 주의! -1 빼고 값을 넣어야 제대로 인덱싱 된다.)

- 선택 정렬

- 퀵 정렬

- 삽입 정렬

- 병합 정렬

| 알고리즘    | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고                                   |
| ----------- | ------------- | ------------- | ------------- | -------------------------------------- |
| 버블 정렬   | O(n2)         | O(n2)         | 비교와 교환   | 코딩이 가장 쉽다                       |
| 카운팅 정렬 | O(n + k)      | O(n + k)      | 비교환 방식   | n이 비교적 작을때만 가능하다           |
| 선택정렬    | O(n2)         | O(n2)         | 비교와 교환   | 교환의 횟수가 버블, 삽입정렬보다 작다. |
| 퀵 정렬     | O(n log n)    | O(n2)         | 분할 정복     | 평균적으로 가장 빠르다                 |
| 삽입 정렬   | O(n2)         | O(n2)         | 비교와 교환   | n의 개수가 작을 때 효과적이다          |
| 병합 정렬   | O(n log n)    | O(n log n)    | 분할 정복     | 연결리스트의 경우 가장 효율적인 방식   |



### 5. 완전검색과 탐욕(Greedy) 알고리즘

- 문제풀이시 완전검색으로 시작하라 (수행속도가 느리다, 해답을 못찾을 확률이 낮다)

완전검색을 위한 순열(Permutation)은 nPr = n! / (n-r)!의 관계를 가진다. nPn = n!이라고 표기하며 Factorial이라 한다.

```python
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i1 and i3 != i2:
                    print(i1, i2, i3)
```

- 탐욕(Greedy) 알고리즘은 최적해를 구하는 근시안적인 방법으로 여러 경우 중 하나를 결정해야할 때마다 그 순간에 최적이라 생각되는 것을 선택해 나아가는 방식으로 최종해답에 도달한다. 각 시점에서 지역적으로 최적의 선택을 하지만, 최종해가 최적이라는 보답은 없다. 일반적인 사람의 단순사고흐름에 따른 해와 비슷하다.

1단계 - 해 선택 - 현재 상태에서 부분 문제의 최적 해를 구한 뒤 이를 부분해집합에 추가한다.

2단계 - 실행 가능성 검사 - 새로운 부분해 집합이 실행 가능한지를 확인한다.

3단계 - 해 검사 - 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 전체문제의 해가 완성되지 않았으면 1번부터 다시 반복한다.

````python
#baby-gene문제에서 탐욕 알고리즘의 예

num = input()
c = [0] * 12

for i in range(6):
    c[int(num[i])] += 1

tri = 0
ru = 0
i = 0
while i < 10:
    if c[i] >= 3:
        c[i] -= 3
        tri += 1
        continue
    if c[i] > 0 and c[i+1] > 0 and c[i+2] > 0:
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        ru += 1
        continue
    i += 1
````
