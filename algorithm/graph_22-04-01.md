## 그래프

### 1. 그래프

- 그래프는 정점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료구조이다. 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N관계를 가지는 원소를 표현하기에 용이하다.

- 트리는 간선의 수가 노드의 수보다 1 적다는 관계가 있지만 그래프는 그렇지 않다

- v개의 정점을 가지는 그래프는 최대 v(v-1)/2개의 간선을 가질 수 있다.

- 그래프의 유형의 예로는 아래와 같다.

  무향 그래프(Undirected Graph)

  유향 그래프(Directed Graph)

  가중치 그래프(Weighted Graph)

  사이클이 없는 방향 그래프(DAG, Directed Acyclic Graph)

- 경로 중 한 정점을 최대 한번만 지나는 경로를 단순경로라 하며, 시작한 정점에서 끝나는 경로를 사이클(Cycle)이라 한다. 

- 간선 정보의 저장 방식은 메모리나 성능을 고려해서 결정한다

  인접 행렬(Adjacent Matrix) : |v|*|v| 크기의 2차원 배열을 이용해서 간선 정보를 저장. 포인터 배열

  ```python
  V, E = map(int, input().split())
  arr = list(map(int, input().split()))
  adjM = [[0] * (V + 1) for _ in range(V + 1)]
  
  for i in range(E):
      n1, n2 = arr[i * 2], arr[i * 2 + 1]
      adjM[n1][n2] = 1
      adjM[n1][n2] = 1  # 무향 그래프의 경우 표시
  ```

  인접 리스트(Adjacent List) : 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장

  ```python
  for i in range(E):
      n1, n2 = arr[i * 2], arr[i * 2 + 1]
      adjL[n1].append(n2)
      adjL[n2].append(n1)  # 무향 그래프의 경우 표시
  ```

  간선의 배열 : 간선을 배열에 연속적으로 저장

  

### 2. 그래프 순회(탐색)

- 깊이우선탐색(Depth First Search) 

  cf) 경로의 개수를 알아야 할 때에는 방문 설정을 반복문 후에 풀어줘야 한다.

  ```python
  # 인접 행렬의 경우
  def dfs1(i, V):  # V 정점 개수
      visited[i] = 1
      print(i, end = ' ')
      for j in range(V + 1):
          if adjm[i][j] and visited[j] == 0:
              dfs1(j, V)
  
  # 인접 리스트의 경우
  def dfs2(i, V):
      visited[i] = 1
      print(i, end = ' ')
      for j in adjL[i]:
          if visited[j] == 0:
              dfs2(j, V)
              
  # 재귀가 아닌 스택으로 구현
  def dfs3(i):
      s = []
  	s.append(i)
      visited[i] = 1
      while s:
          j = s.pop()
          visited[j] = 1
          for k in adjL[j]:
              if visited[k] == 0:
                  s.append(k)
                  visited[k] = 1  # 스택에 있는 정점이 중복되어 스택에 쌓이지 않게하기.
  ```

- 너비우선탐색(Breadth First Search)

  cf) append, pop(0) < deque.append, deque.popleft < front, rear indexing 순으로 속도가 빠르다.

  ```python
  def bfs(G, i):
      q = []
      q.append(i)
      visited[i] = 1
      while q:
          j = q.pop(0)
          for k in adjL[j]:
              if visited[k] == 0:
                  q.append(k)
                  visited[k] = 1  # visited[j] + 1로 저장하여 경로길이를 표시할 수도 있다.
  ```

  

### 3. 서로소 집합(Disjoint-sets)

- 서로소 또는 상호배타 집합들은 서로 중복 포함된 원소가 없는 집합들이다.

- 집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분한다. 이를 대표자(representative)라 한다.

- 상호배타 집합은 연결 리스트나 트리를 통해 표현할 수 있다.

  연결 리스트 : 같은 집합의 원소들을 하나의 연결 리스트로 관리, 맨 앞의 원소를 대표 원소로, 각 원소는 대표원소를 가리키는 링크를 갖는다.

  트리 : 하나의 집합을 하나의 트리로 표현한다. 자식 노드가 부모 노드를 가리키며, 루트 노드가 대표자가 된다.

- 상호배타 집합의 연산은 집합을 만들고, 찾고, 합치는 연산이 있다.

  ```python
  # 집합을 만드는 연산
  def make_set(x):
      p[x] = x
  
  # 대표 원소를 찾는 연산
  def find_set(x):
      while x != p[x]:  # 본인과 대표원소가 같아질 때까지 올라간다.
          x = p[x]
      return x
  
  # 집합 두개를 합치는 연산
  def union_set(x, y):  # y원소의 대표원소를 찾아서 x원소 집합의 대표자로 합친다.
      p[findset(y)] = findset(x)
  ```

  

### 4. 최소 신장 트리(Minimum Spanning Tree)

