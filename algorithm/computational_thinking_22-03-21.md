## Computational Thinking

### 논리 연산

- p가 명제일 때 명제의 진리값이 반대인 경우 ~p 혹은 ㄱP로 표기하며 not p, p의 부정으로 읽는다.

- 논리곱 AND는 p^q이며 둘 다 참일때만 참이되는 연산이다.
- 논리합 OR은 pVq이며 둘 중 하나만 참이여도 참이되는 연산이다.
- 배타적 논리합 (O과 +가 합쳐진 기호)은 둘 중 하나만 참일 때 참이되는 연산이다.



- 항진명제는 진릿값이 항상 참

- 모순명제는 진릿값이 항상 거짓
- 사건명제는 항진명제도 모순명제도 아닌 명제



- 조건명제

| p    | q    | p -> q |
| ---- | ---- | ------ |
| T    | T    | T      |
| T    | F    | F      |
| F    | T    | T      |
| F    | F    | T      |

- 쌍방조건명제

| p    | q    | p <-> q |
| ---- | ---- | ------- |
| T    | T    | T       |
| T    | F    | F       |
| F    | T    | F       |
| F    | F    | T       |



- 역은 q -> p
- 이는 ~p -> ~q
- 대우는 ~q -> ~p



### 2. 논리와 증명

- 명제들을 증명할 때에는 진리표를 이용하면 간단하다.
- 수학적 귀납법은 f(n)이 참인것을 증명하는게 아니라 f(n+1)이 참임을 증명하는 것이다.
- 홀수와 짝수는 2k+1, 2k로 표현하여 증명하면 편하다.
- 마땅한 증명방법이 떠오르지 않을 때에는 대우를 증명해 본다.
- 귀류법은 명제의 부정을 참이라 가정했을 때 생기는 모순을 보여서 원래의 명제가 참임을 보이는 증명방법이다.



### 3. 수의 표현

- log(n)은 2의 몇제곱이 n이 되는가에 대한 답, n을 표현하는데 몇 비트가 필요한가의 답, n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답이다.
- x = log(n)에서 x와 n을 비교하면 x가 더 작고, n이 커질수록 차이는 커진다.
- log(n)비트로 표현 가능한 숫자 범위는 n이다.



### 4. 기초 수식

- T(n) = T(f(n)) + g(n) 점화식을 O() notation으로 바꾸는 방법은 f(n)을 감소한 정도 인 k에 대한 식으로 나타내고, f(n)이 주어진 값(보통 1또는 0) 만큼 줄어들었을 때 k와 n의 관계를 이용해 k자리에 n에대한 식을 넣으면 된다.

- 재귀함수를 점화식으로 나타내는 방법은 T(n)에서 걸리는 시간과 재귀하는 함수를 표현한 뒤 최소 상계로 표현한다. 예를들어 피보나치 수열의 경우 T(n) = T(n-1) + T(n-2) + 1 < 2T(n-1) + 1 = 2^k * T(n-k) + 2^(k+1) + ... + 1 = 2^n T(0) + 2^n - 1이 되어 O(2^n)이 된다.



### 5. 순열과 조합

순열 nPr = n! / r!

조합 nCr = n! / (n-r)!r!	괄호()로 표현하기도 한다.

중복순열 nPIr = n^r

중복조합 nHr = (n+r-1)! / (n-1)!r!	꺽쇠 <>로 표현하기도 한다. n개중 r개를 중복하여 조합하는 경우이며 n+r-1개의 칸에 r-1개의 칸막이를 설치하는 것과 같은 결과를 얻는다.
