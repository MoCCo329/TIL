## Start

### 1. SW 문제 해결

- 복잡도 분석

복잡도는 입력 크기에 대한 함수로 표기하는데, 이를 단순하게 표현하기 위해 점근적 표기(Asymptotic Notation)를 사용한다.

O(Big-Oh) 표기는 복잡도의 점근적 상한을 나타낸다. f(n) < cg(n)이다.

W(Big-Omega) 표기는 복잡도의 점근적 하한을 의미한다. 빅 오메가 표기도 복잡도 다항식의 최고차항만 계수 없이 취하면 된다. f(n) > cg(n)

T(Theta) 표기는 빅오 표기와 빅오메가 표기가 같은 경우에 사용한다.

- 자주 사용하는 O-표기

O(1) : 상수 시간(Constant time)

O(log n) : 로그(대수) 시간(Logarithmic time)

O(n) : 선형 시간(Linear time)

O(n log n) : 로그 선형 시간(Log-linear time)

O(n^2) : 제곱 시간(Quadratic time)

O(n^3) : 세제곱 시간(Cubic time)

O(2^n) : 지수 시간(Exponential time)



### 2. 표준 입출력 방법

- 파일의 내용을 표준 입력으로 읽어오는 방법

```python
# 입출력을 콘솔로 보내는 것이 아니라 파일을 거치도록 한다.
import sys
sys.stdin = open("a.txt", "r")
sys,stdout = open("output.txt", "w")
```



### 3. 비트 연산

- 비트 연산자

| 연산자 | 연산자의 기능                                                |
| ------ | ------------------------------------------------------------ |
| &      | 비트단위로 AND 연산을 한다.<br />주로 비트 검사나 비트 클리어에 사용한다. |
| \|     | 비트 단위로 OR 연산을 한다.<br />비트 셋(특정 비트를 1로)    |
| ^      | 비트 단위로 XOR 연산을 한다.(같으면 0, 다르면 1)<br />특정 비트가 비교군과 같은지 확인한다. |
| ~      | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.           |
| <<n    | 비트를 좌측으로 n번 이동                                     |
| >>n    | 비트를 우측으로 n번 이동                                     |

- 엔디안

빅 엔디안(Big-endian)은 작은 자릿수가 뒤에(높은 주소 번호에) 저장된다.

리틀 엔디안(Little-endian)은 작은 자릿수가 앞에(낮은 주소 번호에) 저장된다.



### 4. 진수

- 10진수를 타 진수로 변환하는 방법은 원하는 진법의 수로 나눈 뒤 나머지를 거꾸로 읽어나가면 된다.

- 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 역전시킨다.

- 2의 보수 : 1의 보수로 만들어진 음수값의 최하위 비트에 1을 더한다.



### 5. 실수

- 단정도 실수(32비트) - 부호 1비트, 지수 8비트, 가수 23비트
- 배정도 실수(64비트) - 부호 1비트, 지수 11비트, 가수 52비트
- 가수부(mantissa) : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
- 지수부(exponent) : 실제 소수점의 위치를 지수 승으로 표현한 것 

- 가수부의 맨 앞 1은 저장하지 않는다. 단, 숫자 0의 경우 모두 0으로 채운다.
