## 6. 트리

### 트리(Tree)

트리란 노드끼리 모두 연결되어 있으며, 사이클이 존재하지 않는 그래프이다. 루트 노드가 정해져 있으면 Rooted tree이며, 정해져 있지 않다면 Unrooted tree이다. Unrooted tree에서 리프노드는 차수가 1인 노드가 된다.

<br>

### 이진트리(Binary Tree)

이진트리는 한 노드의 자식 수를 최대 2개로 제한한 트리이다. 이진트리는 배열로 구현할 수 있으며, 한 노드를 i라 할 때, 왼쪽 자식을 i * 2, 오른쪽 자식을 i * 2 + 1로 저장해 구현한다.



이진트리는 재귀를 사용해 탐색을 쉽게 구현할 수 있다.

전위탐색(Preorder Traversal)은 부모 - 왼쪽자식 - 오른쪽자식 순으로 방문한다.

중위탐색(Inorder Traversal)은 왼쪽자식 - 부모 - 오른쪽자식 순으로 방문한다.

후위탐색(Postorder Traversal)은 왼쪽자식 - 오른쪽자식- 부모 순으로 방문한다.

<br>

### 이진탐색트리(Binary Search Tree)

이진 탐색 트리는 이진트리에서 왼쪽 자식은 부모보다 값이 작고, 오른쪽 자식은 값이 커야한다는 조건을 추가한 것이다. 이런 특징으로 이진 탐색 트리를 중위순회하면 오름차순으로 정렬된 값이 나온다.

이진 탐색 트리에서 삽입, 삭제, 탐색의 시간은 O(N)이다. 이는 트리가 한쪽으로 치우쳐진 경우이며, 균형잡힌 트리라면 O(log N)이 된다. 따라서 Red Black Tree나 AVL Tree같이 특정 규칙에 따라 균형잡힌 이진 탐색 트리를 유지하는 경우도 있다.

탐색은 원하는 값과 일치하거나 null에 도달하기 전까지 노드값과 대소비교를 해서 적절한 자식방향으로 내려가면 된다.

```c++
function bst.search(x)
    set node = bst.root                     // root에서 시작합니다.
    while node != null and node.value != x  // node에 들어있는 값이 x가 되기 전까지 계속 반복합니다.
        if node.value > x                   // 노드에 있는 값이 x보다 크다면
            node = node.left                // 왼쪽 자식으로 내려와 탐색을 진행합니다. 
        else                                // 노드에 있는 값이 x보다 작다면
            node = node.right               // 오른쪽 자식으로 내려와 탐색을 진행합니다.
    
    return node                             // 최종 위치를 반환합니다.
```

삽입은 값이 들어갈 위치를 탐색하다 null을 만나면 그곳에 삽입하면 된다. 단 해당 부모의 값을 알아야 왼쪽에 넣을지, 오른쪽에 넣을지 알 수 있다.

```c++
function bst.insert(x)
    set node = bst.root          // root에서 시작합니다.
    set parent = bst.root        // parent도 root로 설정하고 시작합니다.

    while node != null           // node가 null이 되기 전까지 반복합니다.
        parent = node            // parent는 항상 node가 움직이기 직전의 위치로 갱신해줍니다. 
        if node.value > x        // node에 적혀있는 값이 x보다 크다면
            node = node.left     // 왼쪽 자식으로 이동해야 합니다. 
        else                     // node에 적혀있는 값이 x보다 작다면
            node = node.right    // 오른쪽 자식으로 이동해야 합니다.
    
    if parent == null            // Case 1. 비어있는 tree라면
        bst.root = node(x)       // root를 node(x)로 설정해줍니다.
    else if parent.value > x     // Case 2. parent에 적혀있는 값이 추가하려는 값 x보다 크다면
        parent.left = node(x)    // parent의 왼쪽에 node(x)를 넣어줍니다.
    else                         // Case 3. parent에 적혀있는 값이 추가하려는 값 x보다 작다면
        parent.right = node(x)   // parent의 오른쪽에 node(x)를 넣어줍니다.
```

삭제는 세가지 케이스로 나뉜다.

삭제하려는 값 왼쪽 노드가 비어있다면 오른쪽 노드를 위로 올려준다.

삭제하려는 값 오른쪽 노드가 비어있다면 왼쪽 노드를 위로 올려준다.

삭제하려는 값의 왼쪽, 오른쪽 노드가 모두 있다면 삭제한 값 다음으로 큰 수를 오른쪽 노드에서 찾아야 한다. 이를 successor라 하며 오른쪽 노드에서 왼쪽으로 최대한 내려면 찾을 수 있다. successor를 찾은 뒤, 삭제한 위치에 넣어주며 successor의 오른쪽 자식이 있다면 원래 successor 위치로 올려주면 된다.

```c++
function bst.delete(x)                      // x를 찾아 삭제하는 함수입니다.
    set node = bst.search(x)                // x 값을 찾습니다.
    
    if node.left == null                    // Case 1. node의 왼쪽 자식이 비어있다면
        move(node.right, node)              // 오른쪽 자식을 위로 올려줍니다.
    else if node.right == null              // Case 2. node의 오른쪽 자식이 비어있다면
        move(node.left, node)               // 왼쪽 자식을 위로 올려줍니다.
    else                                    // Case 3. 왼쪽 오른쪽 자식이 모두 채워져있다면
        set succ = bst.minimum(node.right)  // 해당 노드의 successor를 구합니다.
                                            // 이는 현재 노드의 오른쪽 자식에서 시작하여 계속 왼쪽으로 내려가는 것을
                                            // 반복하면 가능합니다.
        if succ == node.right               // 만약 successor가 현재 노드의 오른쪽 자식이라면 
            move(node.right, node)          // 오른쪽 자식을 위로 올려줍니다.
        else                                // 그렇지 않은 일반적인 경우라면
            node.value = succ.value         // node의 값을 successor의 값으로 대체시켜준 뒤,
            move(succ.right, succ)          // successor의 오른쪽 자식을 위로 끌어올려줍니다.
```



### 우선순위큐(Priority Queue)

