## 10. 그래프 알고리즘

### Union-Find

그래프에서 특정 원소가 어떤 집합에 속해있는지 확인하기 편한 집합 자료구조이다. 노드가 속한 집합의 대표자를 찾는것을 Find, 두 집합을 합치는 것을 Union이라 한다.

각 노드번호별로 배열공간이 있으며, 초기값은 자기 자신을 가리킨다. Find는 uf배열값이 자기 자신을 가리킬 때까지 계속 올라가는 방식으로 구현할 수 있다.

```c++
function find(x)
  if uf[x] == x        // x가 루트 노드라면
    return x           // x 값을 반환합니다.
  return find(uf[x])   // x가 루트 노드가 아니라면, x의 부모인 uf[x]에서 더 탐색을 진행합니다.
```

Union은 두 집합의 대표자를 찾아서 하나를 다른 대표에 붙여주면 된다.

```c++
function union(x, y)
  set X = find(x), Y = find(y)
  uf[X] = Y
```



Union과정을 통해 자료구조가 Tree모양이 된다. 하지만 균형잡힌 트리가 아니기에 Union과 Find 연산을 수행하는데 O(N)의 시간복잡도를 갖게되며 이를 위해 두가지 최적화 방법이 있다.

1. Rank/Size compression

   이는 Union시 집합의 높이(Rank)나 사이즈에 따라 더 작은 집합을 큰 집합에 붙여 트리의 균형을 유지시키는 방법이다. 연산이 O(log N)의 시간 복잡도를 갖게된다.

2. Path compression

   Find를 재귀적으로 실행하다 루트 정점을 구하고 재귀함수를 빠저나올때 모든 경로의 정점을 루트정점에 달아주는 것이다. 이 최적화를 진행했을때도 연산당 O(log N)에 가능하며 두 최적화를 모두 진행한다면 O(Ackermann function(N))의 시간복잡도를 갖는다.
   
   ```python
   def find(x):
       if uf[x] != x:
   	    uf[x] = find(uf[x])
       return uf[x]
   ```

<br>

### 다익스트라(Dijkstra Algorithm)

5일차와 동일

<br>

### 플로이드 워셜(Floyd Warshall)

모든 정점끼리의 거리를 알아야 하고, 간선의 수가 많아진다면 다익스트라를 정점 수만큼 반복하는 것보다 좋은 알고리즘이 있다. 플로이드 워셜 알고리즘은 O(V ^ 3)의 시간복잡도를 가지며, 이는 다익스트라를 V번 반복한 O(V^3)이나 O(VE logV)과 같거나 빠른 시간 복잡도이다.

이후 5일차와 동일

<br>

### 크루스칼(Kruskal)

크루스칼은 연결그래프에서 최소한의 간선을 사용해 그래프의 모든 정점을 잇는 Spanning Tree를 구하는 알고리즘이다. Spanning Tree 중에서도 간선 가중치 합이 최소가 되도록 하는 최소 신장 트리(Minimum Spanning Tree, MST)를 구할 수 있다.

모든 간선 중 가중치가 가장 작은 간선을 차례대로 선택하게된다. 선택했을 때 사이클이 발생하는 경우 선택해서는 안되며 사이클이 생기는지 여부는 간선 양 끝 노드가 같은 집합에 속하는지 Find 함수를 통해 확인하면 된다.

간선을 정렬하는데 O(E logE), 각 간선에 대해 Union-Find를 진행하는것이 O(logN)이므로 E logE + E logE가 되어 O(E logE)의 시간 복잡도를 갖는다.

```c++
function kruskal()
    mst = []                       // mst를 담을 배열입니다.
    sort edge[] by length          // 간선을 가중치 기준으로 오름차순 정렬합니다.
    uf = uf_init(|V|)              // uf 배열을 노드의 수 |V|만큼 초기화합니다.

    for E in edge[]                // 각각의 간선에 대해 
        u, v = E                   // 간선을 이루고 있는 두 노드 u, v를 보며
        if find(u) != find(v)      // u, v의 루트 노드가 다른 경우에만
            mst.push(E)            // mst에 해당 간선을 넣어주고
            union(u, v)            // u, v를 같은 루트 노드를 갖도록 만들어줍니다.
    
    return mst
```

<br>

### 프림(Prim)

프림은 한 지점에서 시작하여 점점 확장해나가며 MST를 찾는 알고리즘이다. 한 정점에 연결된 간선 중 가중치가 가장 작은 간선을 찾고, 해당 간선 반대편의 노드를 연결한다. 노드가 연결된다는 것은 인접한 다른 노드까지 확장하는데 필요한 가중치들을 최신화 시킨다는 것이다.

이 방식은 다익스트라 알고리즘과 거의 동일하며, 최소 비용 리스트를 최신화 하는 방법에만 차이가 있다. 다익스트라의 경우 Dist[v] = min(Dist[v], Dist[u] + len(u, v))로 최신화 하지만, 프림은 Dist[v] = min(Dist[v], len(u, v)) 이다.

시간 복잡도는 다익스트라와 마찬가지로 (간선의 수) X (우선순위 큐 이용) 시간복잡도인 O(E logV) 혹은 O(V^2)가 된다.

```c++
function prim(graph)                          // 그래프와 시작점 정보가 주어집니다.
    set Q = Queue()                           // 우선순위 큐를 만들어줍니다.

    for each vertex in graph                  // 그래프에 있는 모든 노드들에 대해
        set dist[v] = INF                     // 초기값을 전부 아주 큰 값으로 설정해주고 
        Q.push(v)                             // 우선순위큐에 각 노드를 넣어줍니다.
    set source = |V|                          // 시작점을 임의로 마지막 노드로 설정합니다.
    set dist[source] = 0                      // 시작점 대해서만 dist 값을 0으로 초기화해줍니다.
    while Q is not empty                      // 우선순위 큐가 비어있지 않을 때까지 반복합니다.
        set u = vertex in Q with min dist     // 우선순위 큐에서 dist값이 가장 작은 노드를 선택합니다.
        Q.remove(u)                           // 우선순위 큐에서 해당 노드를 제거해줍니다.

        for each neighbor v of u              // u번 노드와 연결된 노드들을 전부 살펴보면서
            set alt = length(u, v)            // 간선 가중치를 살펴봅니다.
            if alt < dist[v]                  // 기존 dist값보다 더 alt값이 작다면
                set dist[v] = alt             // dist값을 갱신해줍니다.
```

<br>

### 위상 정렬(Topological Sort)

방향성 그래프에서 앞 노드를 거쳐야만 뒤에 이어진 노드를 갈 수 있다면 어떤 순서로 방문해야 하는지 구하는 방법을 위상정렬이라 한다. 무방향 그래프에서는 순서가 정의되지 않아 위상정렬 알고리즘을 적용할 수 없으며, 사이클이 있는 경우에도 적용할 수 없다. 위상정렬에는 크게 DFS를 이용한 방법과 in-degree를 이용한 방법이 있다.

DFS를 이용한 방법은 (방문하지 않은 한 노드를 고르고 DFS로 인접 정점들을 방문하는 것)을 방문하지 못한 정점이 없어질 때까지 반복하는 것이다. DFS로 방문했다 더 이상 갈 곳이 없을 때 후퇴하며 stack에다가 방문 노드를 기록하면 모든 방문이 완료됐을 때 위상 정렬 순서가 stack에 거꾸로 담겨있게 된다. 이는 각 정점과 간선을 한 번씩 보게 되므로 O(V + E)의 시간 복잡도를 갖는다.

In-degree를 이용한 방법은 In-degree가 0인 지점을 시작으로 하여 해당 정점에 연결된 다른 정점들의 In-degree를 1씩 감소시키고, 다시 In-degree가 0인 지점을 Queue에 담아 반복하는 것이다. 마찬가지로 O(V + E)의 시간 복잡도를 갖는다.