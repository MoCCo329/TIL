## Data Structure

### Priority Queue

우선순위 큐는 우선순위가 가장 높은 데이터만 먼저 나갈 수 있는 형태의 자료구조이다.

이는 배열, 연결 리스트를 통해서도 구현이 가능하지만 힙을 이용해야 삽입, 삭제, 탐색 시간을 O(log N)으로 맞출 수 있어 보통 힙을 이용해 우선순위 큐를 구현한다.

파이썬에서 큐를 사용하려면 heapq를 import 하여 사용하며 이는 min-heap이기에 최댓값(max-heap)을 찾는경우 넣을 때 모두 -를 붙여 넣으면 된다.

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.items = []
    def push(self, item):
        heapq.heappush(self.items, -item)
    def empty(self):
        return not self.items
   	def size(self):
        return len(self.items)
    def pop(self):
        if self.empty():
            raise Exception("PriorityQueue is empty")
        return -heapq.heappop(self.items)
    def top(self):
        if self.empty():
            raise Exception("PriorityQueue is empty")
        return -self.items[0]
```



1. 수열을 입력받고, 홀수 번째의 원소를 읽을 때 마다 지금까지 입력받은 값의 중앙값을 출력하는 프로그램을 작성해보세요.

   ```python
   import heapq
   
   T = int(input())
   
   for tc in range(1, T + 1):
       M = int(input())
       arr = list(map(int, input().split()))
       large = []
       small = []
       middle = 0
       for i in range(M):
           num = arr[i]
           if i == 0:
               middle = num
           else:  # 중앙값보다 작으면 small에 크면 large에 넣는다.
               if num > middle:
                   heapq.heappush(large, num)
               else:
                   heapq.heappush(small, -num)
           if i % 2 == 0:  # 홀수번째면 middle값을 다시 잡고 출력한다.
               if len(large) > len(small):
                   heapq.heappush(small, -middle)
                   middle = heapq.heappop(large)
               elif len(large) < len(small):
                   heapq.heappush(large, middle)
                   middle = -heapq.heappop(small)
               print(middle, end=' ')
       print()



## Shorten time Technique

### Prefix Sum
