## Data Structure

### Priority Queue

우선순위 큐는 우선순위가 가장 높은 데이터만 먼저 나갈 수 있는 형태의 자료구조이다.

이는 배열, 연결 리스트를 통해서도 구현이 가능하지만 힙을 이용해야 삽입, 삭제, 탐색 시간을 O(log N)으로 맞출 수 있어 보통 힙을 이용해 우선순위 큐를 구현한다.

파이썬에서 큐를 사용하려면 heapq를 import 하여 사용하며 이는 min-heap이기에 최댓값(max-heap)을 찾는경우 넣을 때 모두 -를 붙여 넣으면 된다.

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.items = []
    def push(self, item):
        heapq.heappush(self.items, -item)
    def empty(self):
        return not self.items
   	def size(self):
        return len(self.items)
    def pop(self):
        if self.empty():
            raise Exception("PriorityQueue is empty")
        return -heapq.heappop(self.items)
    def top(self):
        if self.empty():
            raise Exception("PriorityQueue is empty")
        return -self.items[0]
```



1. 수열을 입력받고, 홀수 번째의 원소를 읽을 때 마다 지금까지 입력받은 값의 중앙값을 출력하는 프로그램을 작성해보세요.

   ```python
   import heapq
   
   T = int(input())
   
   for tc in range(1, T + 1):
       M = int(input())
       arr = list(map(int, input().split()))
       large = []
       small = []
       middle = 0
       for i in range(M):
           num = arr[i]
           if i == 0:
               middle = num
           else:  # 중앙값보다 작으면 small에 크면 large에 넣는다.
               if num > middle:
                   heapq.heappush(large, num)
               else:
                   heapq.heappush(small, -num)
           if i % 2 == 0:  # 홀수번째면 middle값을 다시 잡고 출력한다.
               if len(large) > len(small):
                   heapq.heappush(small, -middle)
                   middle = heapq.heappop(large)
               elif len(large) < len(small):
                   heapq.heappush(large, middle)
                   middle = -heapq.heappop(small)
               print(middle, end=' ')
       print()



## Shorten time Technique

### Prefix Sum

전처리(Preprocessing)의 대표적인 방법으로 누적합을 미리 계산하여 이용해 문제를 해결하는 방법이다. 보통 맨 앞에 빈값을 넣어준다. 2차원 배열에서 S(i, j) = S(i - 1, j) + S(i, j - 1) - S(i - 1, j - 1) + A(i, j)이다.

1. 1에서 100 사이의 숫자로만 이루어진 n * n 크기의 2차원 격자 상태가 주어졌을 때, k * k 크기의 정사각형이 격자를 벗어나지 않게 잡았을 때 정사각형 내 숫자들의 합이 최대가 되도록 하는 프로그램을 작성해보세요.

   ```python
   N, K = map(int, input().split())
   arr = [[0] * (N + 1)] + [[0] + list(map(int, input().split())) for _ in range(N)]
   n_arr = [[0] * (N + 1) for _ in range(N + 1)]
   
   for i in range(1, N + 1):
       for j in range(1, N + 1):
           n_arr[i][j] = n_arr[i - 1][j] + n_arr[i][j - 1] - n_arr[i - 1][j - 1] + arr[i][j]
   
   ans = 0
   for i in range(K, N + 1):
       for j in range(K, N + 1):
           ans = max(ans, n_arr[i][j] - n_arr[i - K][j] - n_arr[i][j - K] + n_arr[i - K][j - K])
   print(ans)
   ```

   

### Grid Compression

좌표 압축은 정점 번호가 매우 크게 주어졌을때 정점번호를 크기순서대로 나열하여 1번부터 다시 번호를 매기는 것이다. 이를 통해 vidisted 배열을 사용 할 수 있다. 구현 방식은 TreeSet으로 주어진 입력값들을 받고, 하나씩 꺼내서 HashMap에다 원래번호를 key로 압축번호를 value로 하여 저장하는 것이다.

```python
from sortedcontainers import SortedSet

edges = [
    (1, 10**9), (1, 2000), (1, 4), (30, 10**9), (6, 7)
]

nums = SortedSet()

# 사용되는 모든 번호를 treeset에 넣어줍니다.
for v1, v2 in edges:
    nums.add(v1)
    nums.add(v2)

# treeset에서 정점을 작은 번호부터 뽑으면서 각 정점별로 1번부터 순서대로 매칭하여 그 결과를 hashmap에 넣어줍니다.
mapper = dict()
cnt = 1
for num in nums:
    mapper[num] = cnt
    cnt += 1

# 주어진 간선을 이루는 정점 번호를 새로운 정점 번호로 변경해줍니다.
for i in range(5):
    v1, v2 = edges[i]
    edges[i] = (mapper[v1], mapper[v2])
```

