## 13. 패턴일치

### 1. 고지식한 패턴 검색 알고리즘

문자열 t와 p를 인덱스 i와 j로 검사할 때, j<M and i<N인 한 t[i]와 p[j]가 일치하면 i, j를 동시에 증가, 실패하면 i원점에서 한칸 증가(i-j+1)하고 j는 0으로 되돌린다.

O(MN)의 시간복잡도를 갖는다.

<br>

### 2. 카프-라빈 알고리즘

패턴을 해쉬함수를 거치고 문자열을 해쉬값으로 매칭하며 확인하는 방식이다.

매번 해쉬값을 구하면 고지식한 패턴 검색과 다를바가 없으므로 다음 해시값을 구할 때 새로 들어오는 수만 추가하고 맨 뒤 값은 버린 뒤 해쉬값을 구한다.

패턴이 길어지면 mod 연산을 취하기 때문에 해쉬 충돌이 일어날 수 있다.

O(MN)의 시간복잡도를 가지지만, 평균적으론 M + N 이다.

<br>

### 3. KMP 알고리즘

불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행한다.

O(M+N)의 시간복잡도를 갖는다.

```python
T = input()
P = input()
tL = len(T)
pL = len(P)
lps = [0] * pL  # lps[i] 는 1 ~ i 까지 가장 긴 접두사==접미사 길이

j = 0
for i in range(1, pL):
    while j > 0 and P[i] != P[j]:
        j = lps[j - 1]

    if P[i] == P[j]:
        j += 1
        lps[i] = j

ans_list = []
j = 0
for i in range(tL):
    while j > 0 and T[i] != P[j]:
        j = lps[j - 1]

    if T[i] == P[j]:
        if j == pL - 1:
            ans_list.append(i - pL + 2)
            j = lps[j]
        else:
            j += 1

print(*ans_list)
```

실패함수를 Naive 하게 구하면 O(M ^ 3) 이 된다. 따라서 귀납법을 활용해 O(M)에 구하도록 한다.

P[1, i] 마다 모든 가능한 접두사 / 접미사 쌍을 검도하여 실패함수를 만들어보자. 가능한 쌍은 i - 1 개 이며 비교연산시간은 길이에 비례하므로 (i - 1) + (i - 2) + ... + 1 = i * (i - 1) / 2 이다. 모든 i 에 대해 계산하면 O(M ^ 3) 이 된다. (abaaba에서 P[1, 6] 의 실패함수를 구할 때 길이 5의 abaab, baaba 부터 길이 1의 a, a 까지 비교)

f(i) 를 i번 글자의 실패함수 값이라 하면 P[k + 1] == P[f(k) + 1] 과 동일하다면 f(k + 1) = f(k) + 1이다. 다르다면 P[k + 1] 과 P[f(f(k)) + 1] 를 비교, 같다면 f(k + 1) = f(f(k)) + 1, 다르다면 계속 k 를 f(k)로 바꿔 비교한다. (P[i - f(i) + 1, i] 와 P[1, f(i)] 이 일치를 가정하므로, P[1, f(i)]의 접두사와 일치하는 P[i - f(i) + 1, i]의 접미사 중 가장 긴 것은 P[1, f(f(i))] 이다.)

무엇이 패턴이고 무엇이 택스트인지 언급이 없으면 찾는 과정이 추가로 필요하다.

<br>

### 4. 보이어-무어 알고리즘

오른쪽에서 왼쪽으로 비교하는 방식으로 대부분의 소프트웨어에서 채택하고 있다. 패턴의 오른쪽 끝에 있는 문자가 불일치 하고, 이 문자가 패턴 내에 존재하지 않는 경우, 패턴의 이동길이만큼 이동하는 방식이다.

패턴의 오른쪽 끝에 있는 문자가 불일치 한 경우 패턴의 뒤에서부터 비교했던 택스트의 문자와 일치하는 문자가 있는지 찾고, 일치하는 문자가 있으면 그 부분까지 점프한다.

skip 배열을 활용하며 skip[ch]는 ch 문자에서 패턴 불일치가 발생했을 때 이동할 문자열 포인터 수를 나타낸다.

패턴 포인터는 패턴의 맨 뒤를 가리키다가 일치하는 글자를 찾으면 패턴의 다른 글자도 확인한다.

최선의 경우 O(N/M)(빅 오메가로 최선의 경우를 표시 가능) 최악의 경우 O(MN)(빅오는 최악의 경우, 세타는 평균적인 복잡도)의 시간 복잡도를 갖는다.

